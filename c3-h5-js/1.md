## html

- 如何理解 HTML 语义化?

  - 让人更容易读懂(增加代码可读性, 使用不同的标签元素)
  - 让搜索引擎更容易读懂(SEO)

- 块级元素和内联元素?
  - dispaly: block/table; 有 div,h1-h6, table ul ol p 等
  - display: inline/inline-block; 有 span img input button 等

## css

- 盒模型宽度计算

  - offsetWidth = (内容宽度 + 内边距 + 边框), 无外边距

- margin 纵向重叠问题

  - 相邻元素的 margin-top 和 margin-bottom 会发生重叠现象
  - 空白内容的标签也会重叠

- margin 负值问题

  - margin-top 和 margin-left 负值,元素向上/向左移动
  - margin-right 负值,右侧元素左移,自身不受影响
  - margin-bottom 负值,下方元素上移,自身不受影响

- BFC 理解与应用

  - Block format context, 块级格式化上下文
  - 一块独立渲染区域,内部元素的渲染不会影响边界以外的元素
  - 形成 BFC 的常见条件

    - floct 不是 none
    - pasition 是 absolute 或 fixed
    - overflow 不是 visible
    - display 是 flex inline-block 等

  - 应用
    - 清除浮动

- float 布局
  - 圣杯布局和双飞翼布局的目的
    - 三栏布局,中间一栏最先加载和渲染(内容最重要)
    - 两侧内容固定, 中间内容随着宽度自适应
- 圣杯布局和双飞翼布局的技术总结

  - 使用 float 布局
  - 两侧使用 margin 负值,以便和中间内容横向重叠
  - 防止中间内容
    被两侧覆盖, 需要留白,一个用 padding(圣杯 + 定位) 一个用 margin(双飞翼)

- flex 布局
  - 常用语法
    - flex-direction
    - flex-wrap
    - justify-content
    - align-self
    - align-items
- absolute 和 relative 定位

  - relative 依据自身定位
  - absolute 依据最近一层的定位元素定位

- 水平居中

  - inline 元素: text-align: center;
  - block 元素: margin: auto;
  - absolute 元素: left:50%;margin-left 负值

- 垂直居中

  - inline 元素: line-height 的值等于 height 值
  - absolute 元素: top:50% + margin-top 负值
  - absolute 元素: transform(-50%, -50%)
  - absulute 元素: top,left,bottom,right =0 + margin: auto

- 网页视口尺寸
  - window.screen.height // 屏幕高度
  - window.innerHeight // 网页视口高度
  - document.body.clientHeight // body 高度

## js

- 除了 == null 之外, 其他一律用 ===

### 原型关系

- 每个 class 都有显示原型 prototype
- 每个实例都有隐式原型**proto**
- 实例的**proto**指向对应的 class 的 prototype

> 所有的自由变量的查找,是在函数定义的地方,向上级作用域查找,不是在执行的地方!

- 将参数拆解为数组
  - const args = Array.prototype.slice.call(arguments)

### promise 三种状态

- pendding
- resolved
- rejected

- async 修饰的函数返回值为 promise 对象

  ```javascript
  async function fn1() {
    // return 100;  // 相当于 return Promise.resolve(100)
    return Promise.resolve(200);
  }

  // 如 await 后面是一个Promise, 相当于 Promise then
  // const res = await 100   // res => 100 不是Promise
  // 也可以理解为 await Promise.resolve(100)
  ```

> 总结: 只要不出错, 返回的是 resolved, 只要报错, 返回 rejected
> resolved 触发 then, rejected 触发 catch

> 注: 自执行函数之前加!或; async 和 await 使用 try...catch 捕获

### 异步的本质

- async/await 是消灭异步回调的终极武器
- JS 还是单线程, 还行是有异步, 还得基于 event loop

### for...of

- for...of 常用于异步的遍历

### 宏任务和微任务

- 宏任务: setTimeout, setInterval, Ajax,DOM 事件
- 微任务: Promise async/await
- 微任务执行时机要比宏任务早

### 为什么微任务执行时机要比宏任务早?

- event loop 和 DOM 渲染
  - 每次 Call Stack 清空(即每次轮询结束),即同步任务执行完
  - 都是 DOM 重新渲染的机会, DOM 结构如有改变则重新渲染
  - 然后再去触发下一次 Event Loop

> 微任务: DOM 渲染前触发
> 宏任务: DOM 渲染后触发
> 微任务是 ES6 语法规定的
> 宏任务是由浏览器规定的

### property 和 attribute

- property: 修改对象属性, 不会体现到 html 结构中(建议使用)
- attribute: 修改 html 属性,会改变 html 结构
- 两者都有可能引起 DOM 重新渲染

### 优化 DOM 操作的性能

- DOM 查询做缓存
- 将频繁操作改为一次性操作(使用文档片段: createDocumentFragment)

### BOM 操作

- navigator
  - const ua = navigator.userAgent
- screen
- location
- history

### ajax 的核心 API

- XMLHttpRequest

  ```js
  // get请求
  const xhr = new XMLHttpRequest();
  xhr.open("GET", "/api", false); // false 异步
  xhr.onreadystatechange = function () {
    // 这里的函数异步执行
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        alert(xhr.responseText);
      }
    }
  };
  xhr.send(null);

  // post请求
  const xhr = new XMLHttpRequest();
  xhr.open("GET", "/login", false); // false 异步
  xhr.onreadystatechange = function () {
    // 这里的函数异步执行
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        alert(xhr.responseText);
      }
    }
  };
  const postData = {
    userName: "zhangsan",
    password: "xxx",
  };
  xhr.send(JSON.stringify(postData));
  ```

  - xhr.readyState
    - 0 - (未初始化)还没有调用 send()方法
    - 1 - (载入)已调用 send()方法,正在发送请求
    - 2 - (载入完成) send()方法执行完成,已经接收到全部的响应内容
    - 3 - (交互) 正在解析响应内容
    - 4 - (完成) 响应内容解析完成, 可以在客户端调用

- 状态码 -跨域: 同源策略, 跨域解决方案
