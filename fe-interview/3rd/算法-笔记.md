# 算法

### 复杂度

- 程序执行时需要的计算量和内存空间(和代码是否简洁无关)
- 复杂度是**数量级**(方便记忆/推广), 不是具体的数字
- 一般针对一个具体的算法, 而非一个完整的系统

### 链表 vs 数组

- 都是有序结构
- 链表: 查询慢O(n), 新增和删除快O(1)
- 数组: 查询快O(1), 新增和删除慢O(n)

> **链表应用**: React Fiber

#### 链表和数组, 哪个实现队列更快?

##### 分析

- 数组是连续存储, push很快, shift很慢

- 链表是非连续存储, add和delete都很快(但查找很慢)

  > **结论**: 链表实现队列更快
  >
  > **性能分析**
  >
  > - 空间复杂度都是O(n)
  > - add时间复杂度: 链表O(1); 数组O(1)

### 链表实现队列

- 单向链表,但要同时记录head和tail
- 要从 tail 入队, 从head出队, 否则出队时 tail 不好定位
- length要实时记录, 不可遍历链表获取

### 二分查找

### 二叉树

#### 遍历

- 前序遍历: **root** -->left --> right
- 中序遍历: left --> **root** --> right
- 后序遍历: left --> right --> **root**

> 二叉搜索树特点: 
>
> - left <= root; 
> - right >= root;
>
> 二叉搜索树的价值: 可使用**二分法**进行快速查找

### 堆

- 完全二叉树
- 最大堆: 父节点 >= 子节点
- 最小堆: 父节点 <= 子节点

#### 逻辑结构 vs 物理结构

- 堆, **逻辑结构**是一棵二叉树
- 但它**物理结构**是一个数组
- 数组: 适合连续存储 + 节省空间(回顾堆栈模型)

#### 堆 vs BST

- 查询比BST慢
- 增删比BST快, 维护平衡更快
- 但整体的时间复杂度都在O(logn)级别, 即树的高度

#### 堆的使用场景

- 特别适合"堆栈模型"
- 堆的数据, 都是在栈中引用的, 不需要从root遍历
- 堆恰巧是数组形式, 根据栈的地址, 可用O(1)找到目标

### 动态规划

- 把一个大问题, 拆解为多个小问题, 逐级向下拆解
- 用递归的思路去分析问题, 再改为循环来实现
- 算法三大思维: 贪心,二分,动态规划

> **嵌套循环可考虑是否可以使用双指针解决**



### 快排

- 获取midValue的两种方式:
- 使用splice, 会修改原数组
- 使用slice, 不会修改原数组 -- 更加推荐

>splice和slice没有区分出来
>
>- 算法本身的时间复杂度就够高O(n*logn)
>- 外加,splice是逐步二分之后执行的,二分会快速削减数量级
>- 如果单独比较splice和slice, 效果会非常明显







