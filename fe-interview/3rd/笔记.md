## 箭头函数

### 不适合用箭头函数的场景

- 对象方法
- 对象原型
- 构造函数
- 动态上下文的回调函数
- Vue生命周期



## TCP三次握手和四次挥手

### 建立TCP连接

- 先建立连接(确保双方都有收发消息的能力)
- 再传输内容(如发送给一个get请求)
- 网络连接是TCP协议,传输内容是HTTP协议

## for in 和 for of

### 适用于不同的数据类型

- 遍历对象: for in 可以, for of 不可以
- 遍历Map Set: for of可以, for in 不可以
- 遍历generator: for of可以, for in不可以

## 可枚举 vs 可迭代

- for ... in用于**可枚举**数据, 如对象, 数组, 字符串, 得到key
- for ... of 用于**可迭代**数据, 如数组, 字符串, Map, Set, 得到value

## for await ... of作用

- for await ... of用于遍历多个Promise, 是Promise.all的替代品



## offset/client/scroll

- offsetHeight offsetWidth: border + padding + content
- clientHeight clientWidth: padding + content
- scrollHeight scrollWidth: padding + 实际内容尺寸



## HTMLCollection 和 NodeList区别

- HTMLCollection是Element的集合
- NodeList是Node的集合

### Node和Element

- DOM是一棵树, 所有节点都是Node
- Node 是Element的基类
- Element是其他HTML元素的基类,如HTMLDivElement

## 扩展: 类数组 --> 数组

```
const arr1 = Array.from(list)
const arr2 = Array.prototype.slice.call(list)
const arr3 = [...list]
```



## Vue computed和watch区别

### 两者用途不同

- computed用于计算产生新的数据, 有缓存
- watch用于监听现有数据

> computed是有缓存的(特点, 不是区别, 因为他们用途不同, 不能算是区别)
>
> method没有缓存



## Vue组件通讯的方式 - 需要补充一下

- props和$emit
- 自定义事件
- $attrs    $listeners(vue2, vue3中合并到了$attrs)
- $parent
- $refs
- provide/inject
- Vuex



## Vuex mutation action区别

- mutation: 原子操作;必须同步代码;
- action: 可包含多个mutation; 可包含异步代码;



## JS严格模式特点

- 全局变量必须先声明
- 禁止使用with
- 创建eval作用域
- 禁止this指向window
- 函数参数不能重名



## HTTP跨域请求时为什么发送options请求

- options请求, 是跨域请求之前的预检查
- 浏览器自行发起的, 无需人为干预
- 不会影响实际的功能

# 知识深度

## JS内存泄漏如何检测?场景有哪些?

- 检测: Performance - 勾选Memory录制, 查看HEAP

- 场景(Vue为例):

  > - 被全局变量,函数引用, 组件销毁时未清除
  > - 被全局事件, 定时器引用, 组件销毁时未清除
  > - 被自定义事件引用, 组件销毁时未清除

  > WeakMap WeakSet 弱引用

### 使用的算法

- 引用计数(之前)
- 标记清除(现代)



## 单线程和异步

- JS 是单线程的(无论在浏览器还是nodejs)
- 浏览器中JS执行和DOM渲染共用一个线程
- 异步



## 宏任务和微任务

- 宏任务: setTimeout  setInterval  网络请求等 
- 微任务: promise  async/await
- 微任务在下一轮DOM渲染之前执行, 宏任务在之后执行



## nodejs异步

- Nodejs同样使用ES语法, 也是单线程, 也需要异步
- 异步任务也分: 宏任务 + 微任务
- 但是, 它的宏任务和微任务, 分不同类型, 有不同优先级 

## vdom真的很快吗

- vdom并不快, JS直接操作DOM才是最快的
- 但"数据驱动视图"要有合适的技术方案, 不能全部DOM重新
- vdom就是目前最合适的技术方案(并不是因为它快, 而是合适)



## 遍历数组, for和forEach哪个快?

- for更快
- forEach每次都要创建一个函数来调用, 而for不会创建函数
- 函数需要独立的作用域, 会有额外的开销
- 越"低级"的代码, 性能往往越好



## nodejs如何开启进程,进程如何通讯?

- 开启子进程child_process.fork和cluster.fork
- 使用send和on传递消息

### 进程process vs 线程 thread

- 进程, OS进行资源分配和调度的最小单位, 有独立内存空间
- 线程, OS进行运算调度的最小单位, 共享进程内存空间
- JS是单线程的,但可以开启多进程执行, 如WebWorker



## 什么是JS Bridge

- JS无法直接调用native API
- 需要通过一些特定的"格式" 来调用
- 这些"格式"就统称JS-Bridge, 例如微信JSSDK



## JS Bridge的常见实现方式

- 注册全局API
- URL Scheme



## requestIdleCallback和requestAnimationFrame的区别

- requestAnimationFrame每次渲染完都会执行, 高优先级
- requestIdleCallback空闲时才执行, 低优先级
- 两者都是宏任务
- 要待DOM渲染完才执行, 肯定是宏任务



## vue每个生命周期都做了什么?

- beforeCreate
  - 创建一个空白的Vue实例
  - data method尚未被初始化, 不可使用
- created
  - Vue实例初始化完成, 完成响应式绑定
  - data  method 都已经初始化完成,可调用
  - 尚未开始渲染模板
- beforeMount
  - 编译模板,调用render生成vdom
  - 还没有开始渲染DOM
- mounted
  - 完成DOM渲染
  - 组件创建完成
  - 开始由"创建创建"进入"运行阶段"
- beforeUpdate
  - data发生变化之后
  - 准备更新DOM(尚未更新DOM)
- updated
  - data发生变化, 且DOM更新完成
  - 不要在updated中修改data, 可能会导致死循环
- beforeUnumout
  - 组件进入销毁阶段(尚未销毁, 可正常使用)
  - 可移除/解绑一些全局事件,自定义事件
- unmounted
  - 组件被销毁了
  - 所有子组件也都被销毁了



## keep-alive组件

- onActivated缓存组件被激活
- onDeactivated缓存组件被隐藏



## Vue什么时候操作DOM比较合适

- mounted和updated都不能保证子组件全部挂载完成
- 使用$nextTick渲染DOM



## AJAx应该在哪个生命周期

- created
- mounted(推荐)



## Vue3 Composition API生命周期有什么区别

- 用setup代替了beforeCreate和created
- 使用Hooks函数的形式, 如mounted改为onMounted()



## Vue2, Vue3  React三者diff算法有何区别?

- Tree diff的优化
  - 只比较同一层级, 不跨级比较
  - tag不同则删掉重建(不再去比较内部的细节)
  - 子节点通过key区分(key的重要性 )

### React diff: 仅右移

### Vue2 diff: 双端比较

### Vue3 diff: 最长递增子序列



## Vue React为何循环时必须使用key?

- vdom diff算法会根据key判断元素是否要删除
- 匹配了key, 则只移动元素 - 性能较好
- 未匹配key, 则删除重建 - 性能较差



### Vue-router三种模式

- Hash
- WebHistory
- MemoryHistory



# 知识广度

## 移动端H5点击有300ms延迟的解决方法

- 背景: double tap to zoom
- FastClick
- width=device-width

## 网络请求中, token和cookie有什么区别

> 答案: 
>
> - cookie: HTTP标准; 跨域限制;配合session使用;
> - token: 无标准;无跨域限制;用于JWT

### cookie

- HTTP无状态, 每次请求都要带cookie,以帮助识别身份
- 服务端也可以向客户端set-cookie, cookie大小限制为4kb
- 默认有跨域限制: 不可以跨域共享,传递cookie

### cookie本地存储

- HTML5之前cookie常被用于本地存储
- HTML5之后推荐使用localStorage和sessionStorage

## 现代浏览器开始禁止第三方cookie

- 和跨域限制不同. 这里是: 禁止网页引入的第三方JS设置cookie
- 打击第三方广告,保护用户隐私
- 新增属性 **SameSite: Strict/Lax/None**; 值可自己选择

## cookie和session

- cookie用于登录验证,存储用户标识(如userId)
- session在服务端, 存储用户详细信息, 和cookie信息一一对应
- cookie + session是常见登录验证解决方案

## token vs cookie

- cookie是HTTP规范, 而token是自定义传递
- cookie会默认被浏览器存储, 而token需自己存储
- token默认没有跨域限制

 

## Session和JWT哪个更好?

> 答案:
>
> - 如有严格管理用户信息的需求(保密, 快速封禁)推荐Session
> - 如没有特殊要求, 则使用JWT(如创业初期的网站)

### Session优点

- 原理简单, 易于学习
- 用户信息存储在服务端, 可快速封禁某个用户

### Session缺点

- 占用服务端内存, 硬件成本高
- 多进程, 多服务器时, 不好同步 -- 需使用第三方缓存, 如redis
- 默认有跨域限制

### JWT优点

- 不占用服务端内存
- 多进程, 多服务器不受影响
- 没有跨域限制

### JWT缺点

- 用户信息存储在客户端, 无法快速封禁某个用户
- 万一服务端密钥被泄漏,则用户信息全部丢失
- token体积一般大于cookie, 会增加请求的数据量



## 如何实现SSO单点登录

> 答案:
>
> - 主域名相同, 则可共享cookie
> - 主域名不同, 则需使用SSO



## HTTP协议和UDP协议的区别

> 答案:
>
> - HTTP是应用层, TCP UDP是传输层
> - TCP有连接, 有断开 , 稳定传输
> - UDP无连接, 无断开, 不稳定传输, 但效率高

### TCP协议

- 有连接(三次握手)
- 有断开(四次挥手)
- 稳定传输

### UDP协议

- 无连接, 无断开
- 不稳定传输, 但效率高
- 如视频会议, 语音通话



## HTTP协议1.0 1.1 2.0有什么区别

### HTTP 1.0

- 最基础的HTTP协议
- 支持基本的GET POST方法

### HTTP 1.1

- 缓存策略cache-control E-tag等
- 支持长连接Connection: keep-alive, 一次TCP连接多次请求
- 断点续传, 状态码206
- 支持新的方法 PUT DELETE等, 可用于Restful API

### HTTP2.0

- 可压缩header, 减小体积
- 多路复用, 一次TCP连接中可以多个HTTP并行请求
- 服务端推送



## 什么是HTTP中间人攻击?如何预防?

> 答案: 伪造证书
>
> 预防: 使用正规厂商的证书



### HTTPS加密传输

- HTTP明文传输
- HTTPS加密传输HTTP + TLS/SSL



##  defer和async有什么区别

> 答案:
>
> - 无: HTML暂停解析, 下载JS, 执行JS, 再继续解析HTML
> - defer: HTML继续解析, 并行下载JS, HTML解析完再执行JS
> - async: HTML继续解析, 并行下载JS, 执行JS, 再解析HTML



## prefetch和dns-prefetch有什么区别?

> 答案: 
>
> - prefetch是资源预获取(和preload相关)
> - dns-prefetch是DNS预查询(和preconnect相关)

### preload和prefetch

- preload资源在当前页面使用, 会**优先**加载
- prefetch资源在未来页面使用, **空闲时**加载



## 你知道哪些前端攻击?该如何预防?

### xss

- Cross Site Script跨站脚本攻击
- 手段: 黑客将JS代码插入到网页内容中, 渲染时执行JS代码
- 预防: 特殊字符替换(前端或者后端)

### CSRF

- Cross Site Request Forgery跨站请求伪造

- 手段: 黑客诱导用户去访问另一个网站的接口, 伪造请求

- 预防: 严格的跨域限制 + 验证码机制

- 预防手段: 

  - 严格的跨域请求限制, 如判断referrer(请求来源)
  - 为cookie设置SameSite, 禁止跨域传递cookie
  - 关键接口使用短信验证码

  > 详细过程
  >
  > - 用户登录了A网站, 有了cookie
  > - 黑客诱导用户到B网站, 并发起A网站的请求
  > - A网站的API发现有cookie, 认为是用户自己操作的

### 点击劫持

- 手段: 界面上蒙上一个透明的iframe, 诱导用户点击
- 预防: 让iframe不能跨域加载

### DDOS

### sql注入



## WebSocket和HTTP区别

- WebSocket协议名是 **WS://** , 可**双端**发起请求
- WebSocket没有跨域限制
- 通过send和onmessage通讯(HTTP通过req和res)

## 描述从输入url到页面展示的完整过程

### 步骤

- 网络请求

  - DNS查询(得到IP), 建立TCP连接(三次握手)

  - 浏览器发起HTTP请求

  - 收到请求响应, 得到HTML源代码

    > 继续请求静态资源
    >
    > - 解析HTML过程中, 遇到静态资源还会继续发起网络请求
    > - JS CSS图片 视频等

- 解析: 字符串 --> 结构化数据

  - HTML构建dom树
  - css构建cssom树(style tree)
  - 两者结合, 形成render tree

- 渲染: 计算, 绘制, 同时执行JS

## 重绘和重排有什么区别?

### 重排

- 重新计算尺寸和布局, 可能会影响其他元素的位置
- 如元素的高度增加

### 重绘



## 如何实现网页多标签tab通讯?

> 答案:
>
> - WebSocket需要服务端, 成本较高
> - localStorage简单易用, 推荐
> - SharedWorker调试不方便, 不兼容IE11































